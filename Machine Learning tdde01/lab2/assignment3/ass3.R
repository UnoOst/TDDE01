library(dplyr) 
library(knitr)
library(kableExtra)

#1, Scale all variables, exclude ViolentCrimesPerPerson
# Implement PCA
# How many features account for 95% of variance in data?
# Proportion of variation explained from PC1 & PC2?

#read data
communities_data <- read.csv("communities.csv")
var_data = communities_data[,1:100]
#vcpp is target variable
vcpp_list = communities_data[101]
vcpp = unlist(vcpp_list)

#scale vars to mean center of data
scaled_var = scale(var_data)
n <- dim(scaled_var)[1]

# Covariance matrix
s = var(scaled_var)

# PCA using eigen(). 
# Eigenanalysis of covar-matrix
eigen_v <- eigen(s)
eigen_values <- eigen_v$values
eigen_vector <- eigen_v$vectors
# Now when we got the Eigenvalues, we can calculate the proportion of variation and how many features are needed to obtain at least 95% of variance in the data
# Calculate how much of the variation each feature captures
var <- cumsum(eigen_values/sum(eigen_values)*100)
var #Table showing the vars that affect most

# 2 Make PCA with princomp() and scoreplot for PC1

library(ggplot2) # Need to have ggplot2 package installed 
res <- princomp(scaled_var)
res$scores[,1]
res$scores[,50]
plot(res$scores[,])
plot(res$scores[,50])
plot(res$scores[,1])
# Variance for each of the components
res.var <- res$sdev^2 

# Calculate how much of the variation each component captures
res.var.per <- cumsum(res.var/sum(res.var))

# Get the name of the top 10 features that contribute most to PC1
loading_scores <- res$loadings[,1]
# Get the magnitudes
abs_scores <- abs(loading_scores) 
abs_score_ranked <- sort(abs_scores, decreasing=TRUE)
top_5_features <- names(abs_score_ranked[1:5])

# Show names of top-5 scores and the scores ( +/-) below
print(res$loadings[top_5_features,1])

# Plot scores of coordinates PC1 & PC2, the first two columns in scores are showing the PC1 and PC2 values
library(ggplot2)

res.data <- data.frame(
  X=res$scores[,1],
  Y=res$scores[,2])

ggplot(data=res.data, aes(x=X, y=Y)) +
  xlab("PC1") +
  ylab("PC2") +
  theme_bw() + geom_point(color="firebrick") +
  ggtitle("PCA Graph 1")

# Plot of the PC scores in the coordinates PC1 & PC2 in which the color of the points is given by ViolentCrimesPerPop
qplot(X, Y, data=res.data, colour=vcpp, xlab = "PC1", ylab = "PC2") + theme_bw() + ggtitle("PCA Graph 2")

#3, Second order Ploynomial Regression. VCPP is target PC1 is feature

x <- res$scores[,1]
y <- vcpp
df = data.frame(x = x, y = y)

# Our task is to fit this data with the best curve
# Plotting with ggplot

ggplot(data=df, aes(x,y)) +
  geom_point() + 
  xlab("PC1") +
  ylab("ViolentCrimesPerPop") +
  geom_smooth(method="lm", formula=y ~ poly(x,2), se = FALSE) +
  theme_bw()

# 4. Using parametric bootstrap to estimate the confidence and prediction bands from the model from step 3
# a) 
#The confidence interval is an interval that displays 95% of the means of the predictions from the bootstrapping function. 
#We can see that the interval is close to the predicted line and that Second order polynomial regression model fits our data well. 
#The confidence interval reflects the uncertainty around the mean predictions. 

# b) 
#The prediction interval reflects the uncertainty around a single value, while a confidence interval reflects the uncertainty around the mean prediction values. The prediction interval is  
#generally much wider than a confidence interval for the same value as we can see below. 
#In this analysis, we are interested in the best fit for the values and not the range in which most of the y-values exists in, so a confidence interval would be more appropriate use. 
#The prediction interval will give a much more uncertain prediction for the best value.

library(boot)

x <- res$scores[,1]
y <- vcpp
df1 <- data.frame(x = x, y = y)

# Compute value mle that estimates model parameters from the data
mle <- lm(y ~ poly(x, 2), df1)

# Write function rng that depends on data and mle and which generates new data
rng=function(df1, mle) {
  data1=df1
  n = length(data1$y)
  
  # Generate new y
  data1$y=rnorm(n,predict(mle, newdata=data1),sd(mle$residuals))
  return(data1)
}

# Write function statistic that depend on data which will be generated by rgn and should return the estimator for confidence interval
f1=function(data1){
  # Fit linear model
  res=lm(y ~ poly(x, 2), data1)
  # Predict values for all Area values from the original data
  P=predict(res,newdata=df1)
  return(P)
}

# Use boot-function for making the bootstrap
res1=boot(df1, statistic=f1, R=1000, mle=mle, ran.gen=rng, sim="parametric")

# Compute confidence bands for linear model
e1 <- envelope(res1)

# Write function statistic that depend on data which will be generated by rgn and should return the estimator for predicted bands
f2 =function(data1){
  # Fit linear model
  res=lm(y ~ poly(x, 2), data=data1) 
  # Predict values for all x values from the original data
  P=predict(res,newdata=df1)
  n=length(df1$y)
  predictedP=rnorm(n,P, sd(mle$residuals))
  return(predictedP)
}

# Use boot-function for making the bootstrap
res2 =boot(df1, statistic=f2, R=10000, mle=mle, ran.gen=rng, sim="parametric")
# Compute prediction bands for linear model
e2 <- envelope(res2)

# Plot the data
ggplot(data=df, aes(x,y)) +
  geom_point() + 
  geom_smooth(method="lm", formula = y ~ poly(x,2), aes(color = "Second order polynomial regression model"), se = FALSE) +
  geom_ribbon(aes(ymin = e1$point[2,], ymax = e1$point[1,], color = "Confidence interval"), alpha = 0.4) + 
  geom_ribbon(aes(ymin = e2$point[2,], ymax = e2$point[1,], color = "Prediction band"), fill = "pink1", alpha = 0.2) +
  scale_color_manual(name = "Model fit", values = c("Second order polynomial regression model" = "blue", "Confidence interval" = "grey70", "Prediction band" = "pink1")) + theme_bw() + labs(x = "PC1", y = "ViolentCrimesPerPop", color = "Legend") + 
  ggtitle("Second order polynomial regression model w/ confidence and prediction analysis") + theme(legend.key = element_rect(fill = "white", colour = "white")) + theme_bw() 
